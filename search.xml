<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git快速上手</title>
    <url>/2025/08/26/git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<p> 要在本地创建Git仓库仓库并连接到远程仓库 <code>git@github.com:xxxx/xxxxxxxx.git</code>，可以按照以下步骤操作：</p>
<span id="more"></span>

<h5 id="1-首先在本地选择一个目录作为仓库存放位置，打开终端并进入该目录："><a href="#1-首先在本地选择一个目录作为仓库存放位置，打开终端并进入该目录：" class="headerlink" title="1.首先在本地选择一个目录作为仓库存放位置，打开终端并进入该目录："></a>1.首先在本地选择一个目录作为仓库存放位置，打开终端并进入该目录：</h5><p>  <code>cd /path/to/your/local/directory</code></p>
<h5 id="2-初始化本地Git仓库："><a href="#2-初始化本地Git仓库：" class="headerlink" title="2.初始化本地Git仓库："></a>2.初始化本地Git仓库：</h5><p> <code>  git init</code></p>
<h5 id="3-将本地仓库与远程仓库关联："><a href="#3-将本地仓库与远程仓库关联：" class="headerlink" title="3.将本地仓库与远程仓库关联："></a>3.将本地仓库与远程仓库关联：</h5><p> <code> git remote add origin git@github.com:xxxxx/xxxxxx.git</code></p>
<p> 验证远程仓库连接是否成功：</p>
<p> <code> git remote -v</code></p>
<p> 如果成功，会显示类似以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">origin git@github.com:xxxxx/xxxxxxx.git (fetch) </span><br><span class="line">origin git@github.com:xxxxx/xxxxxxx.git (push)</span><br></pre></td></tr></table></figure>

<p> 从远程仓库拉取代码（如果远程已有内容）：</p>
<p>  <code>git pull origin main</code></p>
<p> (如果默认分支不是main，可以替换为实际的分支名，如master）</p>
<h5 id="4-添加到本地工作区："><a href="#4-添加到本地工作区：" class="headerlink" title="4.添加到本地工作区："></a>4.添加到本地工作区：</h5><p> <code> git add</code> .</p>
<h5 id="5-提交给本地仓库："><a href="#5-提交给本地仓库：" class="headerlink" title="5.提交给本地仓库："></a>5.提交给本地仓库：</h5><p>  <code>git commit -m &quot;这是提交的描述内容&quot;</code></p>
<h5 id="6-提交到远程仓库："><a href="#6-提交到远程仓库：" class="headerlink" title="6.提交到远程仓库："></a>6.提交到远程仓库：</h5><p><code>git push origin master (master对应提交的远程仓库分支）</code></p>
<p>创建并切换本地仓库分支：<br><code>git checkout -b dev</code></p>
<p>提交当前分支：</p>
<p><code>git push -u origin dev</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>goframe框架简单介绍</title>
    <url>/2025/08/27/goframe%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Go（又称 Golang）是 Google 开发的静态强类型编程语言，而 GoFrame（简称 gf）是基于 Go 语言的一款现代化、企业级开发框架。二者的关系类似于 “JavaScript 与 Vue.js”“Java 与 Spring”——<strong>Go 是基础语言，GoFrame 是基于 Go 语言的上层框架</strong>，用于简化 Go 语言的工程化开发。</p>
<h3 id="一、区别与联系"><a href="#一、区别与联系" class="headerlink" title="一、区别与联系"></a>一、区别与联系</h3><table>
<thead>
<tr>
<th>维度</th>
<th>Go（语言）</th>
<th>GoFrame（框架）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>编程语言，提供语法、 runtime、标准库等基础能力</td>
<td>基于 Go 的开发框架，封装了 Web、ORM、缓存等上层组件</td>
</tr>
<tr>
<td><strong>依赖关系</strong></td>
<td>独立存在，是 GoFrame 的基础</td>
<td>完全依赖 Go 语言，无法脱离 Go 运行</td>
</tr>
<tr>
<td><strong>核心目标</strong></td>
<td>提供简洁、高效、并发安全的语言特性</td>
<td>提供工程化开发规范和工具链，简化复杂业务开发</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>所有 Go 语言能覆盖的领域（后端、云原生等）</td>
<td>主要用于快速开发企业级应用（Web API、微服务等）</td>
</tr>
</tbody></table>
<h3 id="二、语法区别"><a href="#二、语法区别" class="headerlink" title="二、语法区别"></a>二、语法区别</h3><p>GoFrame<strong>不改变 Go 语言本身的语法</strong>（它是框架而非语言扩展），但在<strong>代码规范、开发模式</strong>上有自己的约定，与原生 Go 开发相比有以下差异：</p>
<ol>
<li><p><strong>代码组织规范</strong><br>原生 Go 没有强制的项目结构，而 GoFrame 通过<code>gf cli</code>工具生成标准化项目结构（如<code>api</code>、<code>model</code>、<code>service</code>分层），强制约束代码组织方式，便于团队协作。</p>
</li>
<li><p><strong>结构体标签（Tag）扩展</strong><br>GoFrame 定义了专属的结构体标签（如<code>v:&quot;required&quot;</code>用于参数验证、<code>orm:&quot;name&quot;</code>用于数据库映射），这些标签是框架层面的约定，而非 Go 语言原生语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GoFrame中用于参数验证和ORM映射的结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="type">int</span>    <span class="string">`v:&quot;required&quot; orm:&quot;id,pk&quot;`</span>  <span class="comment">// gf的验证和ORM标签</span></span><br><span class="line">    Name  <span class="type">string</span> <span class="string">`v:&quot;required|length:2,10&quot;`</span>   <span class="comment">// gf的参数验证规则</span></span><br><span class="line">    Age   <span class="type">int</span>    <span class="string">`v:&quot;min:0|max:150&quot;`</span>          <span class="comment">// 原生Go不识别这些标签，由gf框架解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数命名与接口设计</strong><br>GoFrame 遵循 “<code>CamelCase</code>+ 前缀约定”（如<code>ghttp.Get</code>、<code>gorm.Insert</code>），且大量使用接口抽象（如<code>gdb.ORM</code>接口），而原生 Go 标准库的函数命名更简洁（如<code>http.Get</code>、<code>sql.Query</code>）。</p>
</li>
</ol>
<h3 id="三、实现-API-接口时的区别"><a href="#三、实现-API-接口时的区别" class="headerlink" title="三、实现 API 接口时的区别"></a>三、实现 API 接口时的区别</h3><p>以实现一个 “用户注册” API（POST <code>/user/register</code>）为例，对比原生 Go 与 GoFrame 的开发差异：</p>
<h4 id="1-原生-Go-实现（依赖标准库net-http）"><a href="#1-原生-Go-实现（依赖标准库net-http）" class="headerlink" title="1. 原生 Go 实现（依赖标准库net/http）"></a>1. 原生 Go 实现（依赖标准库<code>net/http</code>）</h4><p>需要手动处理路由、参数解析、验证、错误处理等，代码繁琐：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求结构体</span></span><br><span class="line"><span class="keyword">type</span> RegisterRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age   <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Email <span class="type">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册路由</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/user/register&quot;</span>, registerHandler)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 校验请求方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">        w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;method not allowed&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 解析请求体</span></span><br><span class="line">    <span class="keyword">var</span> req RegisterRequest</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;invalid request: &quot;</span> + err.Error()))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 手动验证参数</span></span><br><span class="line">    <span class="keyword">if</span> req.Name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;name is required&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.Age &lt;= <span class="number">0</span> || req.Age &gt; <span class="number">150</span> &#123;</span><br><span class="line">        w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;age must be 1-150&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 模拟数据库操作（需手动写SQL或集成第三方ORM）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回响应</span></span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    json.NewEncoder(w).Encode(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>:    <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;register success&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-GoFrame-实现"><a href="#2-GoFrame-实现" class="headerlink" title="2. GoFrame 实现"></a>2. GoFrame 实现</h4><p>框架封装了路由、参数绑定、验证、ORM 等功能，代码更简洁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gogf/gf/v2/frame/g&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gogf/gf/v2/net/ghttp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求结构体（通过gf标签实现自动验证）</span></span><br><span class="line"><span class="keyword">type</span> RegisterRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    g.Meta <span class="string">`path:&quot;/user/register&quot; method:&quot;post&quot;`</span> <span class="comment">// 路由和方法定义</span></span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`json:&quot;name&quot; v:&quot;required#姓名不能为空&quot;`</span>   <span class="comment">// 自动验证规则</span></span><br><span class="line">    Age    <span class="type">int</span>    <span class="string">`json:&quot;age&quot; v:&quot;min:1|max:150#年龄必须在1-150之间&quot;`</span> <span class="comment">// 自动验证</span></span><br><span class="line">    Email  <span class="type">string</span> <span class="string">`json:&quot;email&quot; v:&quot;email#邮箱格式错误&quot;`</span>       <span class="comment">// 内置邮箱验证</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义响应结构体</span></span><br><span class="line"><span class="keyword">type</span> RegisterResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := g.Server()</span><br><span class="line">    <span class="comment">// 绑定API处理函数（自动关联路由和验证）</span></span><br><span class="line">    s.BindHandler(<span class="built_in">new</span>(RegisterRequest), registerHandler)</span><br><span class="line">    s.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数（参数自动绑定和验证）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHandler</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req RegisterRequest</span><br><span class="line">    <span class="comment">// 自动解析请求并验证参数（失败会自动返回错误）</span></span><br><span class="line">    <span class="keyword">if</span> err := r.Parse(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        r.Response.WriteJson(RegisterResponse&#123;</span><br><span class="line">            Code:    <span class="number">1</span>,</span><br><span class="line">            Message: err.Error(),</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 数据库操作（通过gf的ORM快速实现，无需手写SQL）</span></span><br><span class="line">    <span class="comment">// g.DB().Model(&quot;user&quot;).Insert(req)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 返回响应</span></span><br><span class="line">    r.Response.WriteJson(RegisterResponse&#123;</span><br><span class="line">        Code:    <span class="number">0</span>,</span><br><span class="line">        Message: <span class="string">&quot;register success&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、GoFrame-主要提升的能力"><a href="#四、GoFrame-主要提升的能力" class="headerlink" title="四、GoFrame 主要提升的能力"></a>四、GoFrame 主要提升的能力</h3><p>GoFrame 的核心价值是<strong>降低 Go 语言开发的 “工程化成本”</strong>，主要提升点包括：</p>
<ol>
<li><strong>简化重复工作</strong><br>封装了 Web 开发中的通用需求（路由、参数验证、中间件、ORM、缓存等），避免开发者重复造轮子。例如：<ul>
<li>内置参数验证器（支持正则、范围、自定义规则），无需手动写 if-else 校验；</li>
<li>ORM 支持自动生成 SQL、事务、关联查询，简化数据库操作。</li>
</ul>
</li>
<li><strong>标准化开发流程</strong><br>通过<code>gf cli</code>工具生成标准化项目结构（API 层、业务层、数据层分离），并提供统一的错误处理、日志、配置管理机制，解决团队协作中的 “代码风格混乱” 问题。</li>
<li><strong>增强企业级特性</strong><br>提供微服务、分布式事务、分布式缓存、API 文档自动生成（OpenAPI）等企业级功能，原生 Go 需集成多个第三方库才能实现，而 GoFrame 一站式支持。</li>
<li><strong>提升开发效率</strong><br>支持热重载（<code>gf run</code>）、代码生成（<code>gf gen</code>）、接口自动化测试等工具，大幅缩短开发周期。例如：通过结构体标签自动生成 Swagger 文档，无需手动编写。</li>
<li><strong>优化性能与稳定性</strong><br>框架内部对并发、内存管理做了针对性优化（如对象池、连接池），且经过大量生产环境验证，稳定性优于 “原生 + 零散第三方库” 的组合。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>联系</strong>：GoFrame 是 Go 语言的 “增强工具”，完全基于 Go 语法开发，依赖 Go 的 runtime。</li>
<li><strong>区别</strong>：Go 是语言基础，GoFrame 是框架；前者提供语法和标准库，后者提供工程化解决方案。</li>
<li><strong>核心价值</strong>：GoFrame 通过封装通用能力、标准化开发流程，让开发者更专注于业务逻辑，而非重复的技术细节，特别适合快速开发企业级应用。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go goframe</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言特性</title>
    <url>/2025/08/27/go%E8%AF%AD%E8%A8%80%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1-在定义函数时，参数的类型是写在参数名称之后的"><a href="#1-在定义函数时，参数的类型是写在参数名称之后的" class="headerlink" title="1.在定义函数时，参数的类型是写在参数名称之后的"></a>1.在定义函数时，参数的类型是写在参数名称之后的</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoPost</span><span class="params">(ctx context.Context, crypto *AESCrypto, path, encryptBody <span class="type">string</span>)</span></span> (outDatamap[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>并且函数的出参直接在入参之后加上（）</p>
<p>注意，不仅仅是函数的入参以及出参是这样的，整个go语言都是将数据类型放在数据名称之后的</p>
<h3 id="2-键值对直接插入定义"><a href="#2-键值对直接插入定义" class="headerlink" title="2.键值对直接插入定义"></a>2.键值对直接插入定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>这里代表创建了一个params的键值对元组，其中key值使用的是string类型，value值使用的是string类型</p>
<h3 id="3-包内函数调用方式"><a href="#3-包内函数调用方式" class="headerlink" title="3.包内函数调用方式"></a>3.包内函数调用方式</h3><p>在 Go 语言中，导入包后可以直接通过&#x3D;&#x3D;包名调用包内的导出&#x3D;&#x3D;方法（首字母&#x3D;&#x3D;大写&#x3D;&#x3D;的函数、变量等），形式为 包名.方法名()，这是 Go 语言的标准用法，GoFrame 框架也遵循这一规则。</p>
<p>注意这里还有一条规则，就是函数名为首字母大写的函数可以被包内同级程序（直接使用函数名调用）和包外程序（使用时加上包名.）调用，而首字母小写的函数则是&#x3D;&#x3D;只能&#x3D;&#x3D;被包内同级程序调用（也就是包内的子包的程序是无法调用的），如果是包外则&#x3D;&#x3D;无法调用&#x3D;&#x3D;，如果必须调用，可以在包内添加一个桥接函数（以大写字母开头，引用小写字母的私有函数）。</p>
<ul>
<li><p>注意上述对于包中函数调用的描述同样也适用于变量</p>
</li>
<li><p>Type 创建和管理类型，可以创建自定义类型，或者是将类型取一个别名，创建接口，将多个类型分组定义</p>
</li>
<li><p>面向接口开发，利于解耦，允许先使用后定义，也就是函数的入参可以放置在函数的下方</p>
</li>
<li><p>和c语言，c++一样支持指针操作，<code>var SyncUserList = &amp;qSyncUserList&#123;&#125;</code>代表syncuserlist的值是取qsyncuserlist的地址*abc代表是指针</p>
</li>
</ul>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">func</span> <span class="params">(q *qSyncUserList)</span></span> GetTopic() <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TaskSyncUserList</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代表q指针指向的结构体是gettopic方法的接受体，也就是q指针指向的结构体有这个函数，并且只有这个指针可以调用</p>
<h3 id="5-结构体定义"><a href="#5-结构体定义" class="headerlink" title="5.结构体定义"></a>5.结构体定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserGroupRelation <span class="keyword">struct</span> &#123;</span><br><span class="line">CustId <span class="type">string</span> <span class="string">`json:&quot;custId&quot; dc:&quot;客户编码&quot;`</span></span><br><span class="line">GroupId <span class="type">string</span> <span class="string">`json:&quot;groupId&quot; dc:&quot;组别编码&quot;`</span></span><br><span class="line">DataSources <span class="type">string</span> <span class="string">`json:&quot;dataSources&quot; dc:&quot;数据来源&quot;`</span></span><br><span class="line">AvailCode  <span class="type">string</span> <span class="string">`json:&quot;availCode&quot; dc:&quot;有效性标识&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面每个参数最后的反引号的内容代表了是 Go 语言的<strong>结构体标签</strong>，用于为字段提供额外的元信息，供程序运行时通过反射（reflect）读取和使用。这里包含两类标签：</p>
<ul>
<li>json:”custId”：用于     JSON 序列化 &#x2F; 反序列化时的字段映射。表示当结构体与 JSON 互转时，CustId 字段会对应 JSON 中的 custId 键（小写开头，符合     JSON 命名习惯）。</li>
<li>dc:”客户编码”：这是一个自定义标签（可能是项目内部约定，如     “数据字典” 或 “文档注释”），用于说明字段的业务含义，方便开发者理解或自动生成文档。</li>
</ul>
]]></content>
      <categories>
        <category>go语言教程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/08/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>general</category>
      </categories>
      <tags>
        <tag>intro</tag>
      </tags>
  </entry>
</search>
